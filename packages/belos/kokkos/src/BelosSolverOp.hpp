//@HEADER
// ************************************************************************
//
//                 Belos: Block Linear Solvers Package
//                  Copyright 2004 Sandia Corporation
//
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact Jennifer A. Loe (jloe@sandia.gov)
//
// ************************************************************************
//@HEADER

/*! \file BelosSolverOp.h
    \brief This file provides a Belos::Operator interface so Belos solvers
     can be integrated into other codes as an abstract operator.
*/

#ifndef BELOS_SOLVER_OP_H
#define BELOS_SOLVER_OP_H

#include "BelosOperator.hpp"

#include "BelosLinearProblem.hpp"
#include "BelosSolverFactory.hpp"

#include "Teuchos_ParameterList.hpp"

/*! \class Belos::SolverOp
    \brief This class provides an interface to the Belos::Operator class, so Belos solvers can be 
    integrated into other codes as an abstract operator. 
    Thus, Belos can use itself as a preconditioner if need be.  It can
    also be used as the inner iteration of Anasazi :)
    This class can be used with any linear algebra that implements its Belos interface
    via inheritance from Belos::MultiVec and Belos::Operator.
*/

namespace Belos {

template<class ScalarType>
class SolverOp : public Operator<ScalarType> {
private:

  using MultiVector = MultiVec<ScalarType>;
  using Op = Operator<ScalarType>; 

  Teuchos::RCP<SolverManager<ScalarType,MultiVector,Op> > solver_;
  Teuchos::RCP<LinearProblem<ScalarType,MultiVector,Op> > lp_;
  Teuchos::RCP<Teuchos::ParameterList> plist_;

  //! Name of solver to be passed into solver factory. 
  std::string solver_name_;

  /// \brief True if SolverOp should initialize the solution vector to zero before
  ///   calling 'solve' in the 'apply' function.  
  bool initSolnVec_;

public:

  //! @name Constructor / Destructor
  //@{ 
  
    /// \brief Create a SolverOp from the Belos solver \c solver_name  generated by Belos' solver factory.
    ///
    /// The solver is initialized with a LinearProblem (\c lp) and ParameterList (\c plist).
    ///
    /// One should create a new linear problem to pass to the inner solver which is separate
    /// from the linear problem passed to any outer solver. (Both problems may have the same 
    /// operator, but solution and right-hand side vectors need to be maintained separately.)  
    ///
    /// When true, the bool \c initSolnVec causes the solution vector \c Y to be itialized to zero
    /// when apply(X,Y) is called.

  SolverOp( const Teuchos::RCP<LinearProblem<ScalarType,MultiVector,Op> >& lp, 
		  const Teuchos::RCP<Teuchos::ParameterList>& plist,
      const std::string solver_name,
      bool initSolnVec = false )  
  : lp_(lp), 
    plist_(plist),
    solver_name_(solver_name),
    initSolnVec_(initSolnVec)
  {
    Belos::SolverFactory<ScalarType,MultiVector,Op> factory;
    solver_ = factory.create( solver_name_, plist );
    solver_->setProblem( lp_ );
  }

  
  //! Destructor
  virtual ~SolverOp() = default;
  //@}
  
  //! @name Operator application methods
  //@{ 
  
  /// \brief Apply the operator.  Performs a linear solve with right-hand side \c X.
  /// Solution is stored in \c Y.  If \c initSolnVec was set to true, the vector \c Y
  /// will be initialized with zeros before calling solve.  If \c initSolnVec is false, 
  /// the vector \c Y will be used as an initial guess for the linear solve.  
  ///
  /// When using the GmresPoly solver, the polynomial will be applied to \c X at each call
  /// instead of performing a linear solve.  

  void Apply (const MultiVec<ScalarType>& x,  MultiVec<ScalarType>& y,  ETrans trans=NOTRANS) const{
    switch(trans){
      case NOTRANS:
        break;
      case TRANS:
        TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error,
            "Belos::SolverOp::Apply: Transpose not supported. ");
      case CONJTRANS:
        TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error,
            "Belos::SolverOp::Apply: Transpose not supported. ");
      default:
        TEUCHOS_TEST_FOR_EXCEPTION(true, std::invalid_argument,
            "Belos::SolverOp::Apply: Invalid ETrans type ");
    }
    Teuchos::RCP<const MultiVector> vec_X = Teuchos::rcpFromRef(x);
    Teuchos::RCP<MultiVector> vec_Y = Teuchos::rcpFromRef(y);
    if (initSolnVec_)
    {
      vec_Y->MvInit( 0.0 );
      lp_->setInitResVec( vec_X );
    }
    lp_->setProblem( vec_Y, vec_X );
    solver_->solve();
  };
  //@}
  
  //! @name Attribute access functions
  //@{ 

  //! Return the name of the requested solver.
  const std::string getSolverName() const { return solver_name_; };
  
  //! Return whether the operator supports applying its transpose or conjugate transpose.
  bool HasApplyTranspose () const {
    return false;
  }
  //@}	   

};

} //end namespace Belos

// end of file BELOS_SOLVER_OP_H
#endif 

